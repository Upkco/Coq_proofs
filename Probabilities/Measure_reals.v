
(*********************************************************)
(*We try to implement a general version of measure theory*)
(*********************************************************)

(* This is based on https://www-fourier.ujf-grenoble.fr/~edumas/integration.pdf *)

(*This file gives a few theorems on B(R), the borelian sigma algebra on R.*)
(*The aime is to prove that B(R) is generated by the ]a ; + \infty [ where a \in R.*)


(*Axioms*)
Require Import Classical.
Require Import ClassicalChoice.
Require Import FunctionalExtensionality.
Require Import PropExtensionality.
Require Import Description.
Require Import ClassicalDescription.
Require Import List.
Require Import Psatz.
Require Import Rbase.
Require Import Rfunctions.

Load Measure_basics.

Open Scope R_scope.

Check R.


(***********)
(*Intervals*)
(***********)

Definition open_finite_int (a b : R) := fun x => a < x /\ x < b.
Definition closed_finite_int (a b : R) := fun x => a <= x /\ x <= b.
Definition semi_open_left_finite_int (a b : R) := fun x => a < x /\ x <= b.
Definition semi_open_right_finite_int (a b : R) := fun x => a <= x /\ x < b.
Definition left_infinite_open_int (a : R) := fun x => x < a.
Definition left_infinite_closed_int (a : R) := fun x => x <= a.
Definition right_infinite_open_int (a : R) := fun x => a < x.
Definition right_infinite_closed_int (a : R) := fun x => a <= x.

Lemma ineq_neg (a b : R) :
  0 < b -> a - b  < a.
Proof.
  intro Hb. apply Rminus_lt. nra.
Qed.

Lemma compl_left_infinite_open (a : R) :
  compl_in (left_infinite_open_int a) (fun x => True) = right_infinite_closed_int a.
Proof.
  unfold compl_in. unfold left_infinite_open_int. unfold right_infinite_closed_int.
  apply set_ext. intro x. firstorder ; nra.
Qed.


Lemma inter_right_infinite_closed_int (a : R) :
  right_infinite_closed_int a = inter_den (fun n => right_infinite_open_int (a - (/(INR (n+1))))).
Proof.
  unfold right_infinite_closed_int. unfold inter_den. apply set_ext. intro x. split.
  - intro Hax. intro n. unfold right_infinite_open_int.
    assert (a - (/ (INR (n+1))) < a).
    + apply ineq_neg.  apply Rinv_0_lt_compat. apply lt_0_INR. lia.
    + nra.
  - intro H.
    destruct (excluded_middle_informative (a <= x)).
    + assumption.
    + apply Rnot_le_lt in n. exfalso.
      specialize (H (Z.to_nat (up (/((a-x)))))).
      unfold right_infinite_open_int in H. rewrite INR_IZR_INZ in H.
       rewrite Nat2Z.inj_add, Z2Nat.id in H.
      * rewrite plus_IZR in H.
        enough ( / (a - x) < IZR (up (/ (a - x))) + IZR(Z.of_nat 1) ).
        -- enough (/ ((IZR (up (/ (a-x)))) + IZR (Z.of_nat 1) ) < a - x) by nra.
           apply Rinv_lt_contravar in H0.
           ++  rewrite Rinv_involutive in H0 ; nra.
           ++  apply Rmult_lt_0_compat.
              ** apply Rinv_0_lt_compat. nra.
              ** apply Rplus_le_lt_0_compat.
                 --- assert (0 < / (a-x)) by (apply Rinv_0_lt_compat ; nra).
                     generalize (archimed (/ (a-x))).
                     nra.
                 --- apply Rlt_0_1.
        -- apply (Rlt_trans _ (IZR (up (/(a-x))))).
           ++ generalize (archimed (/ (a-x))). nra.
           ++ generalize (Rlt_0_1).
              simpl. nra.
      *apply le_0_IZR. assert (0 < (/ (a-x))) by (apply Rinv_0_lt_compat ; nra).
        generalize (archimed (/ (a-x))). nra.
Qed.





(***********)
(*Notations*)
(***********)

Definition is_open_R (A : R -> Prop) :=
  forall x, A x -> exists epsilon, 0 < epsilon /\ forall y, 0 < y -> y < epsilon -> A (x - y) /\ A (x + y).


Definition M_interesting :=
  generated_sig_alg (fun x => True) (fun A => exists (a : R), A = right_infinite_open_int a).
Definition M_reals_borelian :=
  generated_sig_alg (fun x => True) (fun A => is_open_R A).

(*We want to show that M_reals_borelian = M_interesting.*)


